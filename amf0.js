// Generated by CoffeeScript 1.6.3
(function() {
  var AMFContext, Decoder, Encoder, EncoderStream, TYPE_AMF3, TYPE_ARRAY, TYPE_BOOL, TYPE_DATE, TYPE_LONGSTRING, TYPE_MIXEDARRAY, TYPE_MOVIECLIP, TYPE_NULL, TYPE_NUMBER, TYPE_OBJECT, TYPE_OBJECTTERM, TYPE_RECORDSET, TYPE_REFERENCE, TYPE_STRING, TYPE_TYPEDOBJECT, TYPE_UNDEFINED, TYPE_UNSUPPORTED, TYPE_XML, typeOf,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  TYPE_NUMBER = 0x00;

  TYPE_BOOL = 0x01;

  TYPE_STRING = 0x02;

  TYPE_OBJECT = 0x03;

  TYPE_MOVIECLIP = 0x04;

  TYPE_NULL = 0x05;

  TYPE_UNDEFINED = 0x06;

  TYPE_REFERENCE = 0x07;

  TYPE_MIXEDARRAY = 0x08;

  TYPE_OBJECTTERM = 0x09;

  TYPE_ARRAY = 0x0A;

  TYPE_DATE = 0x0B;

  TYPE_LONGSTRING = 0x0C;

  TYPE_UNSUPPORTED = 0x0D;

  TYPE_RECORDSET = 0x0E;

  TYPE_XML = 0x0F;

  TYPE_TYPEDOBJECT = 0x10;

  TYPE_AMF3 = 0x11;

  AMFContext = require('./context');

  Decoder = (function() {
    Decoder.prototype.endian = 'big';

    Decoder.prototype.offset = 0;

    function Decoder(buffer, offset) {
      this.buffer = buffer;
      this.offset = offset != null ? offset : 0;
    }

    Decoder.prototype.readValue = function() {
      var type, value;
      type = this.buffer.readUInt8(this.offset, this.endian);
      this.offset += 1;
      value = (function() {
        switch (type) {
          case TYPE_NUMBER:
            return this.readNumber();
          case TYPE_BOOL:
            return this.readBoolean();
          case TYPE_STRING:
            return this.readString();
          case TYPE_OBJECT:
            return this.readObject();
          case TYPE_NULL:
            return this.readNull();
          case TYPE_UNDEFINED:
            return this.readUndefined();
          case TYPE_REFERENCE:
            return this.readReference();
          case TYPE_MIXEDARRAY:
            return this.readMixedArray();
          case TYPE_ARRAY:
            return this.readList();
          case TYPE_DATE:
            return this.readDate();
          case TYPE_LONGSTRING:
            return this.readLongString();
          case TYPE_UNSUPPORTED:
            return this.readNull();
          case TYPE_TYPEDOBJECT:
            return this.readTypedObject();
          case TYPE_AMF3:
            return this.readAMF3();
          default:
            return console.log('Undefined type');
        }
      }).call(this);
      return value;
    };

    Decoder.prototype.readNumber = function() {
      var number;
      number = this.buffer.readDoubleBE(this.offset, this.endian);
      this.offset += 8;
      return number;
    };

    Decoder.prototype.readBoolean = function() {
      var number;
      number = this.buffer.readUInt8(this.offset, this.endian);
      this.offset += 1;
      return Boolean(number);
    };

    Decoder.prototype.readString = function() {
      var length, str;
      length = this.buffer.readUInt16BE(this.offset, this.endian);
      this.offset += 2;
      str = this.buffer.toString('utf-8', this.offset, this.offset + length);
      this.offset += length;
      return str;
    };

    Decoder.prototype.readNull = function() {
      return null;
    };

    Decoder.prototype.readUndefined = function() {
      return void 0;
    };

    Decoder.prototype.readReference = function() {
      var int;
      int = this.buffer.readUInt8(this.offset, this.endian);
      return this.offset += 1;
    };

    Decoder.prototype.readList = function() {
      var i, len, _i, _results;
      len = this.buffer.readUInt32BE(this.offset, this.endian);
      this.offset += 4;
      _results = [];
      for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
        _results.push(this.readValue());
      }
      return _results;
    };

    Decoder.prototype.readMixedArray = function() {
      var i, len, _i, _results;
      len = this.buffer.readUInt32BE(this.offset, this.endian);
      this.offset += 4;
      _results = [];
      for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
        _results.push(this.readValue());
      }
      return _results;
    };

    Decoder.prototype.readObject = function() {
      var key, obj;
      obj = {};
      while (key = this.readString()) {
        obj[key] = this.readValue();
      }
      this.offset += 1;
      return obj;
    };

    Decoder.prototype.readTypedObject = function() {
      var klass;
      klass = this.readString();
      return this.readObject();
    };

    Decoder.prototype.readAMF3 = function() {
      var AMF3Decoder, amf3, value;
      AMF3Decoder = require('./amf3').Decoder;
      amf3 = new AMF3Decoder(this.buffer, this.offset);
      amf3.clear();
      value = amf3.readValue();
      this.offset = amf3.offset;
      return value;
    };

    return Decoder;

  })();

  EncoderStream = (function() {
    EncoderStream.prototype.endian = 'big';

    function EncoderStream() {
      this.buffer = new Buffer(0);
    }

    EncoderStream.prototype.write = function(chunk) {
      var buffer;
      buffer = new Buffer(this.buffer.length + chunk.length);
      this.buffer.copy(buffer);
      return chunk.copy(buffer, this.buffer.length + 1);
    };

    EncoderStream.prototype.writeDouble = function(double) {
      var b;
      b = new Buffer(8);
      b.writeDoubleBE(num, 0);
      return this.write(b);
    };

    EncoderStream.prototype.writeUInt8 = function(num) {
      var b;
      b = new Buffer(1);
      b.writeUInt8(num);
      return this.write(b);
    };

    EncoderStream.prototype.writeUInt16 = function(num) {
      var b;
      b = new Buffer(2);
      b.writeUInt16(2);
      return this.write(b);
    };

    return EncoderStream;

  })();

  typeOf = function(object) {
    var funcNameRegex, results;
    if (object === null) {
      return null;
    }
    if (object === void 0) {
      return void 0;
    }
    funcNameRegex = /function (.{1,})\(/;
    results = funcNameRegex.exec(object.constructor.toString());
    if (results && results.length > 1) {
      return results[1];
    } else {
      return '';
    }
  };

  Encoder = (function(_super) {
    __extends(Encoder, _super);

    Encoder.prototype.endian = 'big';

    Encoder.prototype.offset = 0;

    Encoder.prototype.buffers = [];

    function Encoder(buffer, offset) {
      this.buffer = buffer;
      this.offset = offset != null ? offset : 0;
      if (!this.buffer) {
        this.buffer = new Buffer(10485760);
      }
    }

    Encoder.prototype.writeValue = function(value) {
      var klass;
      switch (typeOf(value)) {
        case null:
          return this.writeNull();
        case void 0:
          return this.writeUndefined();
        case "Number":
          return this.writeNumber(value);
        case "String":
          return this.writeString(value);
        case "Array":
          return this.writeList(value);
        case "Object":
          return this.writeObject(value);
        case "ASObject":
          return this.writeTypedObject(value);
        case "Boolean":
          return this.writeBoolean(value);
        default:
          if (klass = this.getClassByName(typeOf(value))) {
            if (klass._amf.amf3) {
              return this.writeAMF3(value);
            }
          }
      }
    };

    Encoder.prototype.getBuffer = function() {
      return this.buffer.slice(0, this.offset);
    };

    Encoder.prototype.writeType = function(type) {
      this.buffer[this.offset] = type;
      return this.offset += 1;
    };

    Encoder.prototype.writeNumber = function(num) {
      this.writeType(TYPE_NUMBER);
      this.buffer.writeDoubleBE(num, this.offset);
      return this.offset += 8;
    };

    Encoder.prototype.writeBoolean = function(bool) {
      this.writeType(TYPE_BOOL);
      if (bool) {
        this.buffer.writeUInt8(1, this.offset, this.endian);
      } else {
        this.buffer.writeUInt8(0, this.offset, this.endian);
      }
      return this.offset += 1;
    };

    Encoder.prototype.writeString = function(str, type) {
      var len;
      if (type == null) {
        type = true;
      }
      if (type) {
        this.writeType(TYPE_STRING);
      }
      len = Buffer.byteLength(str);
      this.buffer.writeUInt16BE(len, this.offset);
      this.offset += 2;
      this.buffer.write(str, this.offset, 'utf-8');
      return this.offset += len;
    };

    Encoder.prototype.writeNull = function() {
      return this.writeType(TYPE_NULL);
    };

    Encoder.prototype.writeUndefined = function() {
      return this.writeType(TYPE_UNDEFINED);
    };

    Encoder.prototype.writeList = function(ary) {
      var value, _i, _len, _results;
      this.writeType(TYPE_ARRAY);
      this.buffer.writeUInt32BE(ary.length, this.offset, this.endian);
      this.offset += 4;
      _results = [];
      for (_i = 0, _len = ary.length; _i < _len; _i++) {
        value = ary[_i];
        _results.push(this.writeValue(value));
      }
      return _results;
    };

    Encoder.prototype.writeObject = function(object, type) {
      var key, value;
      if (type == null) {
        type = true;
      }
      if (type) {
        this.writeType(TYPE_OBJECT);
      }
      for (key in object) {
        if (!__hasProp.call(object, key)) continue;
        value = object[key];
        this.writeString(key, false);
        this.writeValue(value);
      }
      this.writeType(0x00);
      this.writeType(0x00);
      return this.writeType(TYPE_OBJECTTERM);
    };

    Encoder.prototype.writeTypedObject = function(object) {
      this.writeType(0x10);
      this.writeString(object.name, false);
      return this.writeObject(object.object, false);
    };

    Encoder.prototype.writeAMF3 = function(value) {
      var AMF3Encoder, amf3;
      this.writeType(TYPE_AMF3);
      AMF3Encoder = require('./amf3').Encoder;
      amf3 = new AMF3Encoder(this.buffer, this.offset);
      amf3.clear();
      amf3.writeValue(value);
      return this.offset = amf3.offset;
    };

    return Encoder;

  })(AMFContext);

  exports.Encoder = Encoder;

  exports.Decoder = Decoder;

}).call(this);
