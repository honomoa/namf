// Generated by CoffeeScript 1.6.3
(function() {
  var ASObject, AbstractMessage, AcknowledgeMessage, ArrayCollection, AsyncMessage, DESTINATION_CLIENT_ID_HEADER, ENDPOINT_HEADER, ObjectEncoding, REMOTE_CREDENTIALS_HEADER, REQUEST_TIMEOUT_HEADER, SMALL_ATTRIBUTES, SMALL_ATTRIBUTE_FLAGS, SMALL_FLAG_MORE, SMALL_UUIDS, SMALL_UUID_FLAGS, readFlags, typeOf,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  typeOf = function(object) {
    var funcNameRegex, results;
    if (object === null) {
      return null;
    }
    if (object === void 0) {
      return void 0;
    }
    funcNameRegex = /function (.{1,})\(/;
    results = funcNameRegex.exec(object.constructor.toString());
    if (results && results.length > 1) {
      return results[1];
    } else {
      return '';
    }
  };

  ObjectEncoding = {
    STATIC: 0x00,
    EXTERNAL: 0x01,
    DYNAMIC: 0x02,
    PROXY: 0x03
  };

  DESTINATION_CLIENT_ID_HEADER = "DSDstClientId";

  DESTINATION_CLIENT_ID_HEADER = "DSDstClientId";

  ENDPOINT_HEADER = "DSEndpoint";

  REMOTE_CREDENTIALS_HEADER = "DSRemoteCredentials";

  REQUEST_TIMEOUT_HEADER = "DSRequestTimeout";

  SMALL_ATTRIBUTE_FLAGS = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40];

  SMALL_ATTRIBUTES = {
    0x01: 'body',
    0x02: 'clientId',
    0x04: 'destination',
    0x08: 'headers',
    0x10: 'messageId',
    0x20: 'timestamp',
    0x40: 'timeToLive'
  };

  SMALL_UUID_FLAGS = [0x01, 0x02];

  SMALL_UUIDS = {
    0x01: 'clientId',
    0x02: 'messageId'
  };

  SMALL_FLAG_MORE = 0x80;

  readFlags = function(decoder) {
    var byte, done, flags;
    flags = [];
    done = false;
    while (!done) {
      byte = decoder.getByte();
      if ((byte & SMALL_FLAG_MORE) === 0) {
        done = true;
      } else {
        byte = byte ^ SMALL_FLAG_MORE;
      }
      flags.push(byte);
    }
    return flags;
  };

  ASObject = (function() {
    ASObject.prototype.amf3 = true;

    ASObject.prototype.name = null;

    ASObject.prototype.alias = null;

    ASObject.prototype.external = false;

    ASObject.prototype.encoding = ObjectEncoding.STATIC;

    function ASObject(name) {
      this.name = name;
      this.keys = [];
      this.object = {};
    }

    ASObject.prototype._readKeys = function(decoder, ref) {
      var i, length;
      length = ref >> 4;
      if (length === 0) {
        return this.keys = [];
      } else {
        return this.keys = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 1; 1 <= length ? _i <= length : _i >= length; i = 1 <= length ? ++_i : --_i) {
            _results.push(decoder.readString());
          }
          return _results;
        })();
      }
    };

    ASObject.prototype._readamf = function(decoder) {
      var key, obj, _i, _len, _ref;
      obj = new ASObject(this.name);
      obj.encoding = this.encoding;
      if (obj.encoding === ObjectEncoding.STATIC) {
        obj.keys = this.keys;
        _ref = this.keys;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          obj.object[key] = decoder.readValue();
        }
      } else {
        key = decoder.readString();
        while (key) {
          obj.object[key] = decoder.readValue();
          key = decoder.readString();
        }
      }
      return obj;
    };

    ASObject.prototype._writeamf = function(encoder) {
      var key, value, _i, _len, _ref, _ref1, _results;
      if (this.encoding === ObjectEncoding.STATIC) {
        _ref = this.keys;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          _results.push(encoder.writeValue(this.object[key]));
        }
        return _results;
      } else {
        _ref1 = this.object;
        for (key in _ref1) {
          value = _ref1[key];
          encoder.writeString(key, false);
          encoder.writeValue(value);
        }
        return encoder.writeType(0x01);
      }
    };

    return ASObject;

  })();

  ASObject._amf = {
    amf3: true,
    name: null,
    alias: null,
    external: false,
    encoding: ObjectEncoding.STATIC
  };

  ArrayCollection = (function() {
    ArrayCollection.prototype.amf3 = true;

    ArrayCollection.prototype.name = 'ArrayCollection';

    ArrayCollection.prototype.alias = 'flex.messaging.io.ArrayCollection';

    ArrayCollection.prototype.external = true;

    ArrayCollection.prototype.encoding = ObjectEncoding.EXTERNAL;

    function ArrayCollection() {
      this.data = [];
    }

    ArrayCollection.prototype._readamf = function(decoder) {
      var obj;
      obj = new ArrayCollection();
      obj.data = decoder.readValue();
      return obj;
    };

    ArrayCollection.prototype._writeamf = function(encoder) {
      return encoder.writeArray(this.data);
    };

    return ArrayCollection;

  })();

  ArrayCollection._amf = {
    amf3: true,
    name: 'ArrayCollection',
    alias: 'flex.messaging.io.ArrayCollection',
    external: true,
    encoding: ObjectEncoding.EXTERNAL
  };

  AbstractMessage = (function() {
    AbstractMessage.prototype.amf3 = true;

    AbstractMessage.prototype.dynamic = false;

    AbstractMessage.prototype.external = true;

    AbstractMessage.prototype.encoding = ObjectEncoding.EXTERNAL;

    function AbstractMessage(options) {
      if (options == null) {
        options = {};
      }
      this.body = options.body || null;
      this.clientId = options.clientId || null;
      this.destination = options.destination || null;
      this.headers = options.headers || null;
      this.messageId = options.messageId || null;
      this.timestamp = options.timestamp || null;
      this.timeToLive = options.timeToLive || null;
    }

    AbstractMessage.prototype.decodeSmallAttribute = function(attr, decoder) {
      var obj;
      obj = decoder.readValue();
      return obj;
    };

    AbstractMessage.prototype.encodeSmallAttribute = function(attr, encoder) {
      var obj;
      obj = this[attr];
      if (!obj) {
        return obj;
      }
      if (attr === 'timestamp' || attr === 'timeToLive') {
        return obj;
      }
      if (attr === 'messageId' || attr === 'clientId') {
        return null;
      }
      return obj;
    };

    AbstractMessage.prototype._readamf = function(decoder) {
      var attr, byte, flag, flags, idx, _i, _j, _k, _len, _len1, _len2, _results;
      flags = readFlags(decoder);
      if (flags.length > 2) {
        throw 'Too many flags';
      }
      idx = 0;
      _results = [];
      for (_i = 0, _len = flags.length; _i < _len; _i++) {
        byte = flags[_i];
        if (idx === 0) {
          for (_j = 0, _len1 = SMALL_ATTRIBUTE_FLAGS.length; _j < _len1; _j++) {
            flag = SMALL_ATTRIBUTE_FLAGS[_j];
            if (flag & byte) {
              attr = SMALL_ATTRIBUTES[flag];
              this[attr] = decoder.readValue();
            }
          }
        }
        if (idx === 1) {
          for (_k = 0, _len2 = SMALL_UUID_FLAGS.length; _k < _len2; _k++) {
            flag = SMALL_UUID_FLAGS[_k];
            if (flag & byte) {
              attr = SMALL_UUIDS[flag];
              this[attr] = decoder.readValue();
            }
          }
        }
        _results.push(idx += 1);
      }
      return _results;
    };

    AbstractMessage.prototype._writeamf = function(encoder) {
      var attr, byte, flag, flagAttrs, flags, uuidAttrs, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _results;
      flagAttrs = [];
      uuidAttrs = [];
      byte = 0;
      for (_i = 0, _len = SMALL_ATTRIBUTE_FLAGS.length; _i < _len; _i++) {
        flag = SMALL_ATTRIBUTE_FLAGS[_i];
        value = this.encodeSmallAttribute(SMALL_ATTRIBUTES[flag]);
        if (value) {
          byte = byte | flag;
          flagAttrs.push(value);
        }
      }
      flags = byte;
      byte = 0;
      for (_j = 0, _len1 = SMALL_UUID_FLAGS.length; _j < _len1; _j++) {
        flag = SMALL_UUID_FLAGS[_j];
        attr = SMALL_UUIDS[flag];
        value = this[attr];
        if (!value) {
          continue;
        }
        byte = byte | flag;
        uuidAttrs.push(value);
      }
      if (!byte) {
        encoder.writeType(flags);
      } else {
        encoder.writeType(flags | SMALL_FLAG_MORE);
        encoder.writeType(byte);
      }
      for (_k = 0, _len2 = flagAttrs.length; _k < _len2; _k++) {
        attr = flagAttrs[_k];
        encoder.writeValue(attr);
      }
      _results = [];
      for (_l = 0, _len3 = uuidAttrs.length; _l < _len3; _l++) {
        attr = uuidAttrs[_l];
        _results.push(encoder.writeValue(attr));
      }
      return _results;
    };

    return AbstractMessage;

  })();

  AbstractMessage._amf = {
    amf3: true,
    dynamic: false,
    external: true,
    encoding: ObjectEncoding.EXTERNAL
  };

  AsyncMessage = (function(_super) {
    __extends(AsyncMessage, _super);

    AsyncMessage.prototype.amf3 = true;

    AsyncMessage.prototype.alias = 'DSA';

    AsyncMessage.prototype.external = true;

    AsyncMessage.prototype.encoding = ObjectEncoding.EXTERNAL;

    function AsyncMessage() {
      AsyncMessage.__super__.constructor.apply(this, arguments);
    }

    AsyncMessage.prototype._readamf = function(decoder) {
      var byte, flags;
      AsyncMessage.__super__._readamf.apply(this, arguments);
      flags = readFlags(decoder);
      if (flags.length > 1) {
        throw 'Too many flags';
      }
      byte = flags[0];
      if (byte & 0x01) {
        this.correlationId = decoder.readValue();
      }
      if (byte & 0x02) {
        return this.correlationId = decoder.readValue();
      }
    };

    AsyncMessage.prototype._writeamf = function(encoder) {
      AsyncMessage.__super__._writeamf.apply(this, arguments);
      if (typeOf(this.correlationId) === "Buffer") {
        encoder.writeType(0x02);
        return encoder.writeByteArray(this.correlationId);
      } else {
        encoder.writeType(0x01);
        return encoder.writeValue(this.correlationId);
      }
    };

    return AsyncMessage;

  })(AbstractMessage);

  AsyncMessage._amf = {
    amf3: true,
    alias: 'DSA',
    external: true,
    encoding: ObjectEncoding.EXTERNAL
  };

  AcknowledgeMessage = (function(_super) {
    __extends(AcknowledgeMessage, _super);

    AcknowledgeMessage.prototype.amf3 = true;

    AcknowledgeMessage.prototype.alias = 'DSK';

    AcknowledgeMessage.prototype.external = true;

    AcknowledgeMessage.prototype.encoding = ObjectEncoding.EXTERNAL;

    AcknowledgeMessage.prototype.name = 'AcknowledgeMessage';

    function AcknowledgeMessage() {
      AcknowledgeMessage.__super__.constructor.apply(this, arguments);
    }

    AcknowledgeMessage.prototype._readamf = function(decoder) {
      var flags;
      AcknowledgeMessage.__super__._readamf.apply(this, arguments);
      flags = readFlags(decoder);
      if (flags.length > 1) {
        throw 'Too many flags';
      }
      return this;
    };

    AcknowledgeMessage.prototype._writeamf = function(encoder) {
      AcknowledgeMessage.__super__._writeamf.apply(this, arguments);
      return encoder.writeType(0x00);
    };

    return AcknowledgeMessage;

  })(AsyncMessage);

  AcknowledgeMessage._amf = {
    amf3: true,
    alias: 'DSK',
    external: true,
    encoding: ObjectEncoding.EXTERNAL,
    name: 'AcknowledgeMessage'
  };

  exports.AbstractMessage = AbstractMessage;

  exports.AcknowledgeMessage = AcknowledgeMessage;

  exports.ASObject = ASObject;

  exports.ArrayCollection = ArrayCollection;

}).call(this);
